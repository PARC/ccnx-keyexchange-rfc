



icnrg                                                           M. Mosko
Internet-Draft                                                   E. Uzun
Intended status: Standards Track                                 C. Wood
Expires: May 4, 2016                                                PARC
                                                       November 01, 2015


                 CCNx Key Exchange Protocol Version 1.0
                     draft-wood-ccnxkeyexchange-00

Abstract

   This document specifies Version 1.0 of the CCNx Key Exchange (CCNxKE)
   protocol.  The CCNxKE protocol allows two peers to establish a
   shared, forward-secure key for secure and confidential communication.
   The protocol is designed to prevent eavesdropping, tampering, and
   message forgery between two peers.  It is also designed to minimize
   the number of rounds required to establish a shared key.  In the
   worst case, it requires two RTTs between a consumer and producer to
   establish a shared key.  In the best case, no RTTs are required
   (i.e., a consumer may start) transmitting messages right away.  This
   specification is only to derive keys.  It does not specify how those
   keys are used.

   Copyright 2015 Palo Alto Research Center

Status of This Memo

   This document is an Internet-Draft and is NOT offered in accordance
   with Section 10 of RFC 2026, and the author does not provide the IETF
   with any rights other than to publish as an Internet-Draft. Internet-Drafts
   are working documents of the Internet Engineering Task Force (IETF).
   Note that other groups may also distribute working documents as
   Internet-Drafts. The list of current Internet-Drafts is at
   http://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months and may
   be updated, replaced, or obsoleted by other documents at any time. It is
   inappropriate to use Internet-Drafts as reference material or to cite them
   other than as “work in progress.”











Mosko, et al.              Expires May 4, 2016                  [Page 1]

Internet-Draft                   CCNxKE                    November 2015


   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   2
     1.1.  Conventions and Terminology . . . . . . . . . . . . . . .   4
   2.  Goals . . . . . . . . . . . . . . . . . . . . . . . . . . . .   5
   3.  Scope . . . . . . . . . . . . . . . . . . . . . . . . . . . .   6
   4.  Presentation Language . . . . . . . . . . . . . . . . . . . .   6
   5.  CCNxKE Overview . . . . . . . . . . . . . . . . . . . . . . .   6
     5.1.  Connection Establishment Latency  . . . . . . . . . . . .   6
     5.2.  Connection Migration and Resumption . . . . . . . . . . .   7
     5.3.  Re-Transmissions, Timeouts, and Replay Prevention . . . .   7
   6.  The CCNxKE Protocol . . . . . . . . . . . . . . . . . . . . .   8
     6.1.  Round Overview  . . . . . . . . . . . . . . . . . . . . .   8
     6.2.  Round 1 . . . . . . . . . . . . . . . . . . . . . . . . .  11
     6.3.  Round 2 . . . . . . . . . . . . . . . . . . . . . . . . .  14
     6.4.  Round 3 . . . . . . . . . . . . . . . . . . . . . . . . .  16
   7.  Key Derivation  . . . . . . . . . . . . . . . . . . . . . . .  17
   8.  SessionID and Resumption Cookie Properties, Derivation, and
       Usage . . . . . . . . . . . . . . . . . . . . . . . . . . . .  18
   9.  Client Authentication . . . . . . . . . . . . . . . . . . . .  19
   10. Security Considerations . . . . . . . . . . . . . . . . . . .  19
   11. References  . . . . . . . . . . . . . . . . . . . . . . . . .  19
     11.1.  Normative References . . . . . . . . . . . . . . . . . .  19
     11.2.  Informative References . . . . . . . . . . . . . . . . .  21
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  21

1.  Introduction

   DISCLAIMER: This is a WIP draft of CCNxKE and has not yet seen
   significant security analysis.

   Ephemeral sessions a la TLS 1.3 [TLS13] and QUIC [QUIC] are needed
   for some CCN exchanges between consumers and producers.  Currently,
   there does not exist a standard way to establish these sessions.
   Thus, the primary goal of the CCNxKE protocol is to provide privacy
   and data integrity between two CCN-enabled peers (e.g., a consumer
   and producer engaged in session-based communication).  It is built on
   the CCNx 1.0 protocol and only relies upon standard Interest and
   Content Objects as a vehicle for communication.  The CCNxKE protocol
   is used to bootstrap session-based communication, wherein traffic is



Mosko, et al.              Expires May 4, 2016                  [Page 2]

Internet-Draft                   CCNxKE                    November 2015


   encapsulated and encrypted using symmetric-key cryptography for
   transmission between two endpoints (i.e., a consumer and producer).
   The CCNxKE protocol enables this form of communication by
   establishing shared state, i.e., shared, ephemeral, and forward-
   secure symmetric keys.  This protocol has the following three main
   properties:

   -  The peer's identity can be authenticated using asymmetric, or
      public key, cryptography (e.g., RSA [RSA], ECDSA [ECDSA], etc.).
      This authentication can be made optional, but is generally
      required for at least one of the peers.

   -  The negotiation of a shared secret is secure from eavesdroppers
      and man-in-the-middle (MITM) attacks.

   -  The negotiation is reliable: no attacker can modify the
      negotiation communication without being detected by the parties to
      the communication.

   -  The state of a CCNx-KE session can be securely migrated between
      endpoints using a "move token."  This allows authentication and
      authorization to be separated from encryption for a session,
      enabling different systems to perform each of these steps.

   Usage of CCNxKE is entirely independent of upper-layer application
   protocols.  Session-based communication via encapsulation and
   encryption enables secure, confidential, and authenticated
   communication between two peers.  One advantage of this protocol is
   that it facilitates the creation and use of completely ephemeral CCN
   Interest and Content Objects.

   CCNxKE also introduces the use of reverse hash-chained nonces
   [HASHCHAIN] in an Interest name to provide proof of a single
   continued message exchange.  Prior TCP-based protocols, such as TLS
   [TLS13], use the TCP 3-way handshake for such proof.  Prior UDP-based
   protocols, such as QUIC [QUIC], use a session address token that must
   be presented by the client (consumer) to prove ownership of an
   address during a key exchange procedure.

   The main contribution of this work is adapting key exchange
   principles to the CCNx communications model.  CCNxKE achieves its
   goals by applying existing key exchange techniques to the CCNx model
   of Named addresses and the Interest and Content Object pull model.
   CCNxKE only assumes that a consumer knows a first name that initiates
   the key exchange and understands the CCNxKE fields inside an Interest
   and Content Object.  The first Interest does not need to be a CCNxKE
   packet -- the producer can signal back to the consumer that it
   requires CCNxKE before progressing.



Mosko, et al.              Expires May 4, 2016                  [Page 3]

Internet-Draft                   CCNxKE                    November 2015


   Finally, note that this specification does not subsume other ICN-
   compliant key exchange protocols, nor does its existence imply that
   all encryption in an ICN must be based on sessions.  It was designed
   specifically to solve the problem of session-based encryption in ICN.

1.1.  Conventions and Terminology

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in RFC
   2119 [RFC2119].

   The following terms are used:

   Consumer: The CCN consumer initiating the CCNxKE key exchange via a
   first Interest.

   Producer: The CCN producer receiving or accepting the CCNxKE key
   exchange request request Interest.

   Sender: An endpoint that originates a message.

   Receiver: An endpoint that is receiving messages.

   Peer: An endpoint.  When discussing a particular endpoint, "peer"
   refers to the endpoint that is remote to the primary subject of
   discussion.

   Connection: A network path of n >= 1 hops between the consumer and
   producer.

   Endpoint: Either the consumer or producer of the connection.

   Handshake: A series of message exchanges between two peers that is
   used to perform a task (e.g., perform key exchange and derivation).

   Session: An association between a consumer and a producer resulting
   from a CCNxKE handshake.

   DH: A Diffie Hellman key exchange procedure [RFC2631] [DH].

   DH Share: One half of the shared-secret provided by one peer
   performing a DH key exchange.

   Forward-secure: The property that compromising any long-term secrets
   (e.g., cryptographic keys) does not compromise any session keys
   derived from those long-term secrets.




Mosko, et al.              Expires May 4, 2016                  [Page 4]

Internet-Draft                   CCNxKE                    November 2015


   CONFIG information: A data structure created by a producer which
   contains long-term cryptographic material and associated information
   needed by a client to initiate a key-exchange with the producer.

   HELLO exchange: An exchange between a consumer and producer wherein
   the consumer retrieves the CONFIG information from the producer.

   Payload: The payload section of a CCNxMessage as defined in
   [CCNxMessages].

   KEPayload: A payload for information used in the CCNxKE protocol
   which is a generic key-value store.  The KEPayload is _not_ the
   CCNxMessage payload.

   CCNxName: A CCNxName as defined in [CCNxMessages].

   Semi-static: Short-term.

   Short-term Secret (SS): A secret which is derived from the server's
   semi-static DH share and the client's fresh DH share.

   Forward-secure Secret (FSK): A secret which is derived from fresh
   (i.e., generated on demand at random) DH shares from both the
   consumer and producer for the given connection.

   HKDF: Hash-based key-derivation function [RFC5869].

2.  Goals

   The goals of the CCNxKE protocol, in order of priority, are as
   follows:

   1.  Cryptographic security: CCNxKE should be used to securely
       establish a session and all related shared secrets between two
       peers.  Cryptographic properties of interest include: (a)
       forward-secure session key derivation and (b) (state and
       computational) denial-of-service prevention at the producer (see
       [RFC4987]).  For property (a), different keys (and relevant
       algorithm parameters, such as IVs) are established for each
       communication direction, i.e., from consumer to producer and
       producer to consumer.

   2.  Interoperability: Independent programmers should be able to
       develop applications utilizing CCNxKE that can successfully
       exchange cryptographic parameters without knowledge of one
       another's code.





Mosko, et al.              Expires May 4, 2016                  [Page 5]

Internet-Draft                   CCNxKE                    November 2015


   3.  Extensibility: CCNxKE seeks to provide a framework into which new
       public key and symmetric key methods and algorithms can be
       incorporated without breaking backwards compatability or
       requiring all clients to implement new functionality.  Moreover,
       the protocol should be able to support a variety of peer
       authentication protocols, e.g., EAP-TLS, EAP-PWD, or a simple
       challenge-response protocol.

   4.  Relative efficiency: CCNxKE tries to create sessions with minimal
       computation, bandwidth, and message complexity.  In particular,
       it seeks to create sessions with as few end-to-end round trips as
       possible, and also provide support for accelerated session
       establishment and resumption when appropriate.  At most 2 round-
       trip-times (RTTs) should be used to establish a session key, with
       the possibility of 1 or 0 RTT accelerated starts and resumption.

3.  Scope

   This document and the CCNxKE protocol are highly influenced by the
   TLS 1.3 [TLS13] and QUIC [QUIC] protocols.  The reader, however, does
   not need a detailed understanding of those protocols to understand
   this document.  Moreover, where appropriate, references to related
   protocols are made for brevity and technical clarity.  This document
   is intended primarily for readers who will be implementing the
   protocol and for those doing cryptographic analysis of it.  The
   specification has been written with this in mind, and it is intended
   to reflect the needs of those two groups.

   Note that this document is not intended to supply any details of
   service definition or of interface definition, although it does cover
   select areas of policy as they are required for the maintenance of
   solid security.

4.  Presentation Language

   This document uses a presentation language of remote calls (i.e.
   packet messages) similar to the format used by TLS [TLS13].

5.  CCNxKE Overview

5.1.  Connection Establishment Latency

   CCNxKE operates in three rounds, where each round requires a single
   RTT to complete.  The full execution of the protocol therefore
   requires 2 RTTs before a session is fully established.  The full
   version is used when consumers have no a priori information about the
   producer.  An accelerated two round version is used when the consumer
   has valid configuration information about the producer; this variant



Mosko, et al.              Expires May 4, 2016                  [Page 6]

Internet-Draft                   CCNxKE                    November 2015


   requires 1 RTT before a session is established.  Finally, the
   quickest execution of the protocol requires only a single round to
   resume a previous session (similar to the goal of [RFC5077]).
   Indeed, if 0 RTT latency is desired then the consumer must also
   include application data in this initial round.

5.2.  Connection Migration and Resumption

   CCN end hosts lack the notion of addresses.  Thus, the producer
   endpoint for a given execution of the CCNxKE protocol is one which
   can authoritatively serve as the owner of a particular namespace.
   For example, a consumer may wish to establish a session with a
   producer who owns the /company/foo namespace.  The specific end host
   which partakes in the protocol instance is not specified, by virtue
   of the fact that all CCNxKE messages are based on well-defined names.
   This enables the producer end-host which partakes in the protocol to
   change based on the name of the CCNxKE messages.  Consequently, to
   maintain correctness, it is important that a single execution of the
   protocol operates within the same trusted context; this does not mean
   that the same producer end-host is required to participate in all
   three steps of the protocol.  Rather, it means that the end-host
   responding to a CCNxKE message must be trusted by the consumer to
   complete the exchange.  CCNxKE is designed to enable this sort of
   producer migration.

   For example, a consumer may use an initial name like '/parc/
   index.html' that works like an IP any cast address and could got to
   one of several systems.  CCNxKE allows the responding endpoint to
   include a localized name to ensure that subsequent messages from the
   consumer come back to the same producer.  CCNxKE also allows the key
   exchange peer to securely hand-off the session to a content producer
   peer via another name and session token once the client is
   authenticated and keying material is exchanged.

5.3.  Re-Transmissions, Timeouts, and Replay Prevention

   CCNxKE timeouts and retransmissions are handled using the approach in
   [RFC6347].  One primary difference is that timer values may need to
   be adjusted (elongated) due to prefix shifts and the need for a
   producer to transfer security information between different machines.

   Replay attack prevention is also an optional feature, and if used,
   MAY be done using one of the following two approaches at the receiver
   (producer):

   -  IPSec AH [RFC4302] and ESP [RFC4303] style replay detection based
      on sliding windows and monotonically increasing sequence numbers
      for windows.  Note that the sliding window inherently limits the



Mosko, et al.              Expires May 4, 2016                  [Page 7]

Internet-Draft                   CCNxKE                    November 2015


      performance of the protocol to the window size, since only a
      finite number of messages may be received within a given window
      (based on the window size).

   -  The optimized anti-replay algorithm of [RFC6479].

6.  The CCNxKE Protocol

   This section describes the CCNxKE protocol in detail at the message
   level.  The specific encoding of those messages is given later.
   CCNxKE could be adapted to different wire format encodings, such as
   those used by the NDN protocol.

   The following assumptions are made about peers participating in the
   CCNxKE protocol:

   -  Consumers know the namespace prefix of the producer for which they
      wish to execute the CCNxKE protocol.

   -  The CCNxInterest carries a distinguished field that contains
      CCNxKE fields.

   -  The CCNxContentObject carries a distinguished field -- separate
      from the Payload -- that contains the CCNxKE field.  This is
      necessary for 0 RTT packets that carry both keying material and
      application payload.

   -  CCNxKE does not require any special behavior of intermediate
      systems to forward packets.

   -  CCNxKE packets generally should not be cached for significant
      periods of time, as use normal protocol methods to limit caching.
      Part of this is achieved through the use of consumer-specific
      nonces in names.

6.1.  Round Overview

   CCNxKE is composed of three rounds.  The purpose of each round is
   described below.

   -  Round 1: Perform a bare HELLO exchange to obtain the public
      parameters and CONFIG information (detailed later) provided by the
      producer.  The CONFIG information is relatively long-term
      cryptographic material generated by the producer and does not
      require significant computation to produce.  After this round the
      consumer is in possession of the producer CONFIG information that
      is used to begin the real key exchange.




Mosko, et al.              Expires May 4, 2016                  [Page 8]

Internet-Draft                   CCNxKE                    November 2015


   -  Round 2: Perform the initial FULL-HELLO exchange to establish a
      forward-secure key used for future communication, i.e., Interest
      and Content Object exchanges in the context of the newly
      established session.

   -  Round 3: Send the first bit of application data and (optionally)
      transfer resumption cookie(s) from the producer to the consumer.

   Conceptually, there are two secrets that are established during a
   single execution of CCNxKE:

   -  Short-term Secret (SS): A secret which is derived from the
      server's semi-static DH share and the client's fresh DH share.
      Keying material derived from SS is not forward secure.

   -  Forward-secure Secret (FSK): A secret which is derived from fresh
      DH shares from both the consumer and producer for the given
      connection.  Keying material derived from FSK is intended to be
      forward secure.

   All secrets are derived with the appropriate amount of randomness
   [RFC4086].  An overview of the messages sent in each of the three
   rounds to establish and use these secrets is shown in Figure Figure 1
   below.  This diagram omits the optional session migration tokens and
   the quick restart cookie.


























Mosko, et al.              Expires May 4, 2016                  [Page 9]

Internet-Draft                   CCNxKE                    November 2015


       Consumer                                           Producer

       Payload:
       HELLO
                           I[/prefix/nonce1]
                               -------->
                                                           Payload:
                                                             Config
                                                             nonce2*
                                                               salt*
                           CO[/prefix/nonce1]
                               <---------
       Payload:
       ClientShare1
       {AlgorithmOptions}
       {NonceTarget}
       {ClientShare2}
                           I[/prefix/nonce2]
                               -------->
                                                           Payload:
                                                          SessionID
                                                              {ACK}
                                                     {ServerShare2}
                                                               [RC]
                           CO[/prefix/nonce2]
                               <---------
       Payload:
       [ConsumerData]

                           I[/prefix/SessionID/[...]]
                               -------->
                                                           Payload:
                                                     [ProducerData]
                           CO[/prefix/SessionID/[...]]
                               <--------

       (Repeat with data)      <-------->       (Repeat with data)

               *  Indicates optional or situation-dependent
                  messages that are not always sent.

               {} Indicates messages protected using keys
                  derived from the short-term secret (SS)

               [] Indicates messages protected using keys
                  derived from the forward-secure secret (FSK).

        Figure 1: High-level message flow for full CCNxKE protocol



Mosko, et al.              Expires May 4, 2016                 [Page 10]

Internet-Draft                   CCNxKE                    November 2015


   In the following sections, we will describe the format of each round
   in this protocol in more detail.

   We do not specify the encoding of messages sent in Interest and
   Content Object payloads.  Any viable encoding will suffice, so long
   as both parties agree upon the type.  For example, the payload could
   be structured and encoded as a JSON object whose, e.g.,

   { "Config": CONFIG, "nonce2": nonce2_, "salt": salt_ }

   For now, we assume some valid encoding mechanism is used to give
   structure to message payloads.

6.2.  Round 1

   Recall that the purpose of Round 1 is to acquire the CONFIG
   information used in Round 2 of the protocol.  To that end, the format
   of the Round 1 message is trivial.  First, the client issues an
   Interest with the following name

       /prefix/nonce1

   and a HELLO KEPayload with the following information:




























Mosko, et al.              Expires May 4, 2016                 [Page 11]

Internet-Draft                   CCNxKE                    November 2015


   +----------------------+--------------------------------+-----------+
   | HELLO Field          | Description                    | Optional? |
   +----------------------+--------------------------------+-----------+
   | CCS                  | Compressed certificate set     |           |
   |                      | that the consumer possesses.   |           |
   |                      | This is used for generating    |           |
   |                      |                                |           |
   | authenticators by    | No                             |           |
   | the server. See      |                                |           |
   | [QUIC] for more      |                                |           |
   | details.             |                                |           |
   |                      |                                |           |
   | CCRT                 | Cached certificates in the     | No        |
   |                      | consumer's possession          |           |
   |                      |                                |           |
   | VER                  | Supported CCNxKE protocol      | No        |
   |                      | version(s)                     |           |
   |                      |                                |           |
   | PROOF                | Proof of demand (i.e., a       | No        |
   |                      | sorted list of types of proof  |           |
   |                      | the consumer will expect)      |           |
   |                      |                                |           |
   | NONCE1               | A 32-byte hash digest computed | No        |
   |                      | over a random input NONCE-     |           |
   |                      | TOKEN (used later) using       |           |
   |                      | SHA-256                        |           |
   +----------------------+--------------------------------+-----------+

   Upon receipt of this interest, the producer responds with a HELLO-
   REJECT Content Object whose KEPayload has the following fields:





















Mosko, et al.              Expires May 4, 2016                 [Page 12]

Internet-Draft                   CCNxKE                    November 2015


   +--------------+----------------------------------------+-----------+
   | HELLO-REJECT | Description                            | Optional? |
   | Field        |                                        |           |
   +--------------+----------------------------------------+-----------+
   | {REJ}        | Rejection flag                         | No        |
   |              |                                        |           |
   | {REASON}     | Reason for rejection                   | No        |
   |              |                                        |           |
   | CONFIG       | The server CONFIG information          | Yes       |
   |              |                                        |           |
   | NONCE2       | An optional 32-byte nonce to use for   | Yes       |
   |              | the following message in the CCNxKE    |           |
   |              | instance                               |           |
   |              |                                        |           |
   | PSALT1       | An optional 32-byte salt to use when   | Yes       |
   |              | deriving SS                            |           |
   |              |                                        |           |
   | PREFIX2      | An optional CCNxName prefix to use     | Yes       |
   |              | when continuing the session            |           |
   |              | establishment protocol in Round 2      |           |
   +--------------+----------------------------------------+-----------+

   Recall that the CONFIG information is a semi-static catalog of
   information that consumers can use to complete future key exchanges
   with the producer.  The fields of the CONFIG information are shown
   below.

   +-------------+-----------------------------------------+-----------+
   | CONFIG      | Description                             | Optional? |
   | Information |                                         |           |
   | Field       |                                         |           |
   +-------------+-----------------------------------------+-----------+
   | SCID        | Server configuration ID                 | Yes       |
   |             |                                         |           |
   | KEXS        | Supported elliptic-curve key-exchange   | No        |
   |             | algorithms                              |           |
   |             |                                         |           |
   | AEAD        | Supported AEAD algorithms               | No        |
   |             |                                         |           |
   | PUBS        | List of public values (for key exchange | No        |
   |             | algorithm) encoded appropriately for    |           |
   |             | the given group                         |           |
   |             |                                         |           |
   | EXPRY       | Expiration timestamp (i.e., longevity   | No        |
   |             | of the CONFIG structure)                |           |
   |             |                                         |           |
   | VER         | Version of the CONFIG structure         | Yes       |
   +-------------+-----------------------------------------+-----------+



Mosko, et al.              Expires May 4, 2016                 [Page 13]

Internet-Draft                   CCNxKE                    November 2015


   The KEXS is a data structure that enumerates the elliptic curve key-
   exchange algorithms that are supported by the producer (see [QUIC]
   for more details).  Currently, only the following curves are
   supported:

   -  Curve25519

   -  P-256

   Selection criteria for these curves is given at
   http://safecurves.cr.yp.to/.

   The AEAD structure enumerates the supported AEAD algorithms used for
   symmetric-key authenticated encryption after the session has been
   established.  Currently, the only supported algorithms are:

   -  AES-GCM-(128,192,256) [GCM]: a 12-byte tag is used, where the
      first four bytes are taken from the FSK key-derivation step and
      the last eight are taken from the initial consumer nonce.

   -  Salsa20 [SALSA20] (stream cipher) with Poly1305 (MAC).

   The key sizes and related parameters are provided with the AEAD tag
   in the CONFIG structure.

   ((TODO: the exact structure of the AEAD needs to be spelled out here
   for completeness.))

   The PUBS structure contains the public values for the initial key
   exchange.  Both Curve25519 and P-256 provide their own set of
   accepted parameters.  Thus, the only values provided here are the
   random curve elements used in the DH operation.

6.3.  Round 2

   Recall that the purpose of Round 2 is to perform the initial FULL-
   HELLO exchange to establish a forward-secure key used for future
   communication.  It is assumed that the consumer already has the
   CONFIG information that is provided from the producer in Round 1.
   Moreover, assume that nonce2 is a ephemeral nonce provided by the
   producer in Round 1.  Then, the consumer issues an Interest with the
   following name:

       /prefix/nonce2

   and a KEPayload with the following information:





Mosko, et al.              Expires May 4, 2016                 [Page 14]

Internet-Draft                   CCNxKE                    November 2015


   +-----------------+-------------------------------------+-----------+
   | FULL-HELLO      | Description                         | Optional? |
   | Field           |                                     |           |
   +-----------------+-------------------------------------+-----------+
   | CLIENT-SHARE1   | Client public share for the initial | No        |
   |                 | DH exchange                         |           |
   |                 |                                     |           |
   | CSALT1          | Client salt for initial DH exchange | Yes       |
   |                 | and SS generation                   |           |
   |                 |                                     |           |
   | PSALT1          | Echoed producer salt (not optional  | Yes       |
   |                 | if the server provided one)         |           |
   |                 |                                     |           |
   | {PROOF}         | Proof of demand (i.e., a sorted     | No        |
   |                 | list of types of proof the consumer |           |
   |                 | will expect)                        |           |
   |                 |                                     |           |
   | {CCS}           | Compressed certificate set that the | No        |
   |                 | consumer possesses                  |           |
   |                 |                                     |           |
   | {CHALLENGE}     | A random 32-byte challenge that is  | No        |
   |                 | to be signed by the producer        |           |
   |                 |                                     |           |
   | {CHOICE}        | Algorithm (KEXS and AEAD) options   | No        |
   |                 | choice (a list of tags echoed from  |           |
   |                 | the server CONFIG)                  |           |
   |                 |                                     |           |
   | {NONCE-TOKEN}   | The preimage such that SHA-256      | No        |
   |                 | (NONCE-TOKEN) = NONCE1              |           |
   |                 |                                     |           |
   | {CLIENT-SHARE2} | Second share for generating the     | No        |
   |                 | ephemeral key                       |           |
   |                 |                                     |           |
   | {CSALT2}        | Client salt for generating the FSK  | Yes       |
   |                 | key                                 |           |
   +-----------------+-------------------------------------+-----------+

   Upon receipt of this interest, the producer performs the DH
   computation to compute SS, decrypts all protected fields in the
   consumer's KEPayload, and validates the algorithm choice selection
   (CHOICE).  If any of these steps fail, the producer replies with with
   a HELLO-REJECT Content Object whose KEPayload contains a REJ flag and
   the reason of the error.  If the above steps complete without failure
   or error, then the producer responds with a Content Object whose
   KEPayload has the following fields:






Mosko, et al.              Expires May 4, 2016                 [Page 15]

Internet-Draft                   CCNxKE                    November 2015


   +-----------------------+-------------------------------+-----------+
   | HELLO-ACCEPT Field    | Description                   | Optional? |
   +-----------------------+-------------------------------+-----------+
   | SessionID             | Cleartext session identifier  | No        |
   |                       |                               |           |
   | [RC]                  | Resumption cookie encrypted   | Yes       |
   |                       | under a FSK-derived key       |           |
   |                       |                               |           |
   | {ACK}                 | Positive ACK flag indicating  | No        |
   |                       | success                       |           |
   |                       |                               |           |
   | {RESPONSE}            | The signed output of the      | No        |
   |                       | CHALLENGE according to the    |           |
   |                       | PROOF preferences and CCS     |           |
   |                       | certificates in possession of |           |
   |                       | the consumer                  |           |
   |                       |                               |           |
   | {PSALT2}              | 32-byte producer salt for the | Yes       |
   |                       | FSK key exchange              |           |
   |                       |                               |           |
   | {SERVER-SHARE2}       | Server's public key share to  | No        |
   |                       | use when generating MSK       |           |
   |                       |                               |           |
   | {(Prefix3,MoveToken)} | Third CCNxName prefix and     | Yes       |
   |                       | token to use when moving to   |           |
   |                       | session establishment         |           |
   +-----------------------+-------------------------------+-----------+

   ((TODO: we need to spell out what type of flag ACK is (a bit?
   byte?)))

6.4.  Round 3

   In Round 3, the consumer sends interests whose name and optional
   Payload are encrypted using one of the forward-secure keys derived
   after Round 2.  In normal operation, the producer will respond with
   Content Objects whose Payloads are encrypted using a different
   forward-secure key.  That is, interests and Content Objects are
   encrypted and authenticated using two separate keys.  The producer
   may also optionally provide a new resumption cookie (RC) with a
   Content Object response.  This is used to keep the consumer's
   resumption cookie fresh and to also support 0 RTT resumption.  In
   this case, the producer's Content Object response has the following
   fields:

   -  Payload: the actual Content Object payload data encrypted with the
      producer's forward-secure key.




Mosko, et al.              Expires May 4, 2016                 [Page 16]

Internet-Draft                   CCNxKE                    November 2015


   -  RC': A new resumption cookie to be used for resuming this session
      in the future.

   The producer is free to choose the frequency at which new resumption
   cookies are issued to the consumer.

7.  Key Derivation

   The goal of the CCNxKE protocol is to establish the following key
   material:

   consumer write key (FSK-C)
   producer write key (FSK-P)
   consumer write IV  (IV-C)
   producer write IV  (IV-P)

   To get this material, first the SS must be derived.  We use the HKDF
   [RFC5869] function for all key derivation and expansion.  Also, the
   DH operation produces a 32-byte value that used for the HKDF-Expand
   function.

     SS = HKDF(Salt, IKM)
   Salt = CSALT1 || PSALT1 || "ss generation"
    IKM = DH(CLIENT-SHARE1, SERVER-SHARE1)

   Figure 2: SS Derivation.  SERVER-SHARE1 is the share corresponding to
                the consumer's CHOICE selection in Round 2.

    FSK = HKDF(Salt, IKM)
   Salt = CSALT2 || PSALT2 || "fsk generation"
    IKM = DH(CLIENT-SHARE2, SERVER-SHARE2)

   Figure 3: SS Derivation.  SERVER-SHARE1 is the share corresponding to
                the consumer's CHOICE selection in Round 2.

   The keying material FSK-C/P and IV-C/P are then expanded from the FSK
   forward-secure secret in the following order using the HKDF-Expand
   function.

   FSK-C
   FSK-P
   IV-C
   IV-P








Mosko, et al.              Expires May 4, 2016                 [Page 17]

Internet-Draft                   CCNxKE                    November 2015


8.  SessionID and Resumption Cookie Properties, Derivation, and Usage

   The purpose of the session identifier SessionID is to uniquely
   identify a single session for the producer and consumer.  A Producer
   MAY use a random bit string or MAY use the method described in this
   section or MAY use another proprietary method to distinguish clients.

   We provide a more secure creation of the SessionID since it is used
   with the RC derivation (defined later).  Specifically, the SessionID
   is derived as the encryption of the hash digest of a server secret,
   FSK, and an optional prefix (e.g., Prefix3).  Encryption is done by
   the using a long-term secret key owned by the server used for only
   this purpose, i.e., it is not used for consumer traffic encryption.
   Mechanically, this derivation is:

   SessionID = Enc(k1, H(secret || FSK || (Prefix3 | ""))),

   where k1 is the long-term producer key, and "secret" is the
   producer's secret.

   For the resumption cookie, we require that it must be able to be used
   to recover the SS and FSK for a given session.  Without SS and FSK,
   correct session communication is not possible.  We derive it as the
   encryption of the hash digest of the server secret, SS, FSK, and the
   optional (Prefix3, MoveToken) tuple (if created for the session).
   The producer must use a long-term secret key for this encryption.
   Mechanically, this derivation is:

   RC = Enc(k2, SS || FSK || ((Prefix3 || MoveToken) | "")),

   where k2 is again a long-term producer key.  Note that it may be the
   case that k1 = k2 (see above), though this is not required.

   With this SessionID and RC, the consumer then resumes a session by
   providing both the SessionID and RC to the producer.  This is done to
   prove to the producer that the consumer who knows the SessionID is
   also in possession of the correct RC.  The producer verifies this by
   computing

   (SS || FSK || ((Prefix3 || MoveToken)| "")) = Dec(k2, RC)

   and checking the following equality

   SessionID = Enc(k1, H( secret || FSK || ( Prefix3 | "")))

   If equality holds, the producer uses the SS and FSK recovered from RC
   to re-initialize the previous session with the consumer.




Mosko, et al.              Expires May 4, 2016                 [Page 18]

Internet-Draft                   CCNxKE                    November 2015


9.  Client Authentication

   Currently, only the producer is authenticated in the CCNxKE protocol
   using a standard challenge-response protocol.  This could be extended
   to enable mutual authentication for the client by adding a challenge-
   response exchange from the producer to the consumer in Rounds 2 and
   3.  That is, the producer could return a CHALLENGE in Round 2, to
   which the consumer is expected to sign and return as a RESPONSE in
   Round 3 before the producer accepts any application data.

   Additional authentication mechanisms based on EAP may also be used,
   including:

   -  EAP-TLS: EAP based on a TLS-like exchange.

   -  EAP-PWD: EAP based on a password.

   -  EAP-PSK: EAP based on a pre-shared key.

   (( TODO: should we add examples for each of the above variants? ))

10.  Security Considerations

   For CCNxKE to be able to provide a secure connection, both the
   consumer and producer systems, keys, and applications must be secure.
   In addition, the implementation must be free of security errors.

   The system is only as strong as the weakest key exchange and
   authentication algorithm supported, and only trustworthy
   cryptographic functions should be used.  Short public keys and
   anonymous servers should be used with great caution.  Implementations
   and users must be careful when deciding which certificates and
   certificate authorities are acceptable; a dishonest certificate
   authority can do tremendous damage.

11.  References

11.1.  Normative References

   [CCNxMessages]
              Mosko, M. and I. Solis, "CCNx Messages in TLV Format",
              June 2015, <https://tools.ietf.org/html/draft-irtf-icnrg-
              ccnxmessages-00>.

   [DH]       Diffie, W. and M. Hellman, "New Directions in
              Cryptography", IEEE Transactions on Information Theory,
              V.IT-22 n.6 , June 1977.




Mosko, et al.              Expires May 4, 2016                 [Page 19]

Internet-Draft                   CCNxKE                    November 2015


   [ECDSA]    American National Standards Institute, "Public Key
              Cryptography for the Financial Services Industry: The
              Elliptic Curve Digital Signature Algorithm (ECDSA)",
              ANSI ANS X9.62-2005, November 2005.

   [GCM]      Dworkin, M., "Recommendation for Block Cipher Modes of
              Operation: Galois/Counter Mode (GCM) and GMAC",
              NIST Special Publication 800-38D, November 2007.

   [QUIC]     Iyengar, J. and I. Swett, "QUIC: A UDP-Based Secure and
              Reliable Transport for HTTP/2", December 2015.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <http://www.rfc-editor.org/info/rfc2119>.

   [RFC2631]  Rescorla, E., "Diffie-Hellman Key Agreement Method",
              RFC 2631, DOI 10.17487/RFC2631, June 1999,
              <http://www.rfc-editor.org/info/rfc2631>.

   [RFC4086]  Eastlake 3rd, D., Schiller, J., and S. Crocker,
              "Randomness Requirements for Security", BCP 106, RFC 4086,
              DOI 10.17487/RFC4086, June 2005,
              <http://www.rfc-editor.org/info/rfc4086>.

   [RFC4302]  Kent, S., "IP Authentication Header", RFC 4302,
              DOI 10.17487/RFC4302, December 2005,
              <http://www.rfc-editor.org/info/rfc4302>.

   [RFC4303]  Kent, S., "IP Encapsulating Security Payload (ESP)",
              RFC 4303, DOI 10.17487/RFC4303, December 2005,
              <http://www.rfc-editor.org/info/rfc4303>.

   [RFC4987]  Eddy, W., "TCP SYN Flooding Attacks and Common
              Mitigations", RFC 4987, DOI 10.17487/RFC4987, August 2007,
              <http://www.rfc-editor.org/info/rfc4987>.

   [RFC5869]  Krawczyk, H. and P. Eronen, "HMAC-based Extract-and-Expand
              Key Derivation Function (HKDF)", RFC 5869,
              DOI 10.17487/RFC5869, May 2010,
              <http://www.rfc-editor.org/info/rfc5869>.

   [RFC6347]  Rescorla, E. and N. Modadugu, "Datagram Transport Layer
              Security Version 1.2", RFC 6347, DOI 10.17487/RFC6347,
              January 2012, <http://www.rfc-editor.org/info/rfc6347>.





Mosko, et al.              Expires May 4, 2016                 [Page 20]

Internet-Draft                   CCNxKE                    November 2015


   [RFC6479]  Zhang, X. and T. Tsou, "IPsec Anti-Replay Algorithm
              without Bit Shifting", RFC 6479, DOI 10.17487/RFC6479,
              January 2012, <http://www.rfc-editor.org/info/rfc6479>.

   [RSA]      Rivest, R., Shamir, A., and L. Adleman, "A Method for
              Obtaining Digital Signatures and Public-Key
              Cryptosystems", Communications of the ACM v. 21, n. 2, pp.
              120-126., February 1978.

   [SALSA20]  Bernstein, D., "Salsa20 specification",
              www.http://cr.yp.to/snuffle/spec.pdf , April 2005.

   [TLS13]    Rescorla, E., "The Transport Layer Security (TLS) Protocol
              Version 1.3", August 2015.

11.2.  Informative References

   [HASHCHAIN]
              L. Lamport, "Password Authentication with Insecure
              Communication", ANSI Communications of the ACM 24.11, pp
              770-772, November 1981.

   [RFC5077]  Salowey, J., Zhou, H., Eronen, P., and H. Tschofenig,
              "Transport Layer Security (TLS) Session Resumption without
              Server-Side State", RFC 5077, DOI 10.17487/RFC5077,
              January 2008, <http://www.rfc-editor.org/info/rfc5077>.

Authors' Addresses

   M. Mosko
   PARC

   EMail: marc.mosko@parc.com


   Ersin Uzun
   PARC

   EMail: ersin.uzun@parc.com


   Christopher A. Wood
   PARC

   EMail: christopher.wood@parc.com






Mosko, et al.              Expires May 4, 2016                 [Page 21]
