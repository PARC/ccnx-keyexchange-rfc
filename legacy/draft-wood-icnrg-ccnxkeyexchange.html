<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>CCNx Key Exchange Protocol Version 1.0</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
      /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
      a.info {
          /* This is the key. */
          position: relative;
          z-index: 24;
          text-decoration: none;
      }
      a.info:hover {
          z-index: 25;
          color: #FFF; background-color: #900;
      }
      a.info span { display: none; }
      a.info:hover span.info {
          /* The span will display just on :hover state. */
          display: block;
          position: absolute;
          font-size: smaller;
          top: 2em; left: -5em; width: 15em;
          padding: 2px; border: 1px solid #333;
          color: #900; background-color: #EEE;
          text-align: left;
      }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  max-width: 55em;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents"/>
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction"/>
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Conventions and Terminology"/>
<link href="#rfc.section.2" rel="Chapter" title="2 Goals"/>
<link href="#rfc.section.3" rel="Chapter" title="3 Scope"/>
<link href="#rfc.section.4" rel="Chapter" title="4 Presentation Language"/>
<link href="#rfc.section.5" rel="Chapter" title="5 CCNxKE Overview"/>
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 Connection Establishment Latency"/>
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 Connection Migration and Resumption"/>
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 Re-Transmissions, Timeouts, and Replay Prevention"/>
<link href="#rfc.section.6" rel="Chapter" title="6 The CCNxKE Protocol"/>
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 Round Overview"/>
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 Round 1"/>
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 Round 2"/>
<link href="#rfc.section.6.4" rel="Chapter" title="6.4 Round 3"/>
<link href="#rfc.section.7" rel="Chapter" title="7 Key Derivation"/>
<link href="#rfc.section.8" rel="Chapter" title="8 SessionID and Resumption Cookie Properties, Derivation, and Usage"/>
<link href="#rfc.section.9" rel="Chapter" title="9 Client Authentication"/>
<link href="#rfc.section.10" rel="Chapter" title="10 Security Considerations"/>
<link href="#rfc.references" rel="Chapter" title="11 References"/>
<link href="#rfc.references.1" rel="Chapter" title="11.1 Normative References"/>
<link href="#rfc.references.2" rel="Chapter" title="11.2 Informative References"/>
<link href="#rfc.authors" rel="Chapter"/>


  <meta name="generator" content="xml2rfc version 2.5.1 - http://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Mosko, M., Uzun, E., and C. Wood" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-wood-ccnxkeyexchange-00" />
  <meta name="dct.issued" scheme="ISO8601" content="2015-11-01" />
  <meta name="dct.abstract" content="This document specifies Version 1.0 of the CCNx Key Exchange (CCNxKE) protocol.  The CCNxKE protocol allows two peers to establish a shared, forward-secure key for secure and confidential communication. The protocol is designed to prevent eavesdropping, tampering, and message forgery between two peers. It is also designed to minimize the number of rounds required to establish a shared key.  In the worst case, it requires two RTTs between a consumer and producer to establish a shared key. In the best case, no RTTs are required (i.e., a consumer may start) transmitting messages right away. This specification is only to derive keys. It does not specify how those keys are used." />
  <meta name="description" content="This document specifies Version 1.0 of the CCNx Key Exchange (CCNxKE) protocol.  The CCNxKE protocol allows two peers to establish a shared, forward-secure key for secure and confidential communication. The protocol is designed to prevent eavesdropping, tampering, and message forgery between two peers. It is also designed to minimize the number of rounds required to establish a shared key.  In the worst case, it requires two RTTs between a consumer and producer to establish a shared key. In the best case, no RTTs are required (i.e., a consumer may start) transmitting messages right away. This specification is only to derive keys. It does not specify how those keys are used." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
  <td class="left">icnrg</td>
  <td class="right">M. Mosko</td>
</tr>
<tr>
  <td class="left">Internet-Draft</td>
  <td class="right">E. Uzun</td>
</tr>
<tr>
  <td class="left">Intended status: Standards Track</td>
  <td class="right">C. Wood</td>
</tr>
<tr>
  <td class="left">Expires: May 4, 2016</td>
  <td class="right">PARC</td>
</tr>
<tr>
  <td class="left"></td>
  <td class="right">November 01, 2015</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">CCNx Key Exchange Protocol Version 1.0<br />
  <span class="filename">draft-wood-ccnxkeyexchange-00</span></p>
  
  <h1 id="rfc.abstract">
  <a href="#rfc.abstract">Abstract</a>
</h1>
<p>This document specifies Version 1.0 of the CCNx Key Exchange (CCNxKE) protocol.  The CCNxKE protocol allows two peers to establish a shared, forward-secure key for secure and confidential communication. The protocol is designed to prevent eavesdropping, tampering, and message forgery between two peers. It is also designed to minimize the number of rounds required to establish a shared key.  In the worst case, it requires two RTTs between a consumer and producer to establish a shared key. In the best case, no RTTs are required (i.e., a consumer may start) transmitting messages right away. This specification is only to derive keys. It does not specify how those keys are used.</p>
<h1 id="rfc.status">
  <a href="#rfc.status">Status of This Memo</a>
</h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at http://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on May 4, 2016.</p>
<h1 id="rfc.copyrightnotice">
  <a href="#rfc.copyrightnotice">Copyright Notice</a>
</h1>
<p>Copyright (c) 2015 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (http://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a></li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Conventions and Terminology</a></li>
</ul><li>2.   <a href="#rfc.section.2">Goals</a></li>
<li>3.   <a href="#rfc.section.3">Scope</a></li>
<li>4.   <a href="#rfc.section.4">Presentation Language</a></li>
<li>5.   <a href="#rfc.section.5">CCNxKE Overview</a></li>
<ul><li>5.1.   <a href="#rfc.section.5.1">Connection Establishment Latency</a></li>
<li>5.2.   <a href="#rfc.section.5.2">Connection Migration and Resumption</a></li>
<li>5.3.   <a href="#rfc.section.5.3">Re-Transmissions, Timeouts, and Replay Prevention</a></li>
</ul><li>6.   <a href="#rfc.section.6">The CCNxKE Protocol</a></li>
<ul><li>6.1.   <a href="#rfc.section.6.1">Round Overview</a></li>
<li>6.2.   <a href="#rfc.section.6.2">Round 1</a></li>
<li>6.3.   <a href="#rfc.section.6.3">Round 2</a></li>
<li>6.4.   <a href="#rfc.section.6.4">Round 3</a></li>
</ul><li>7.   <a href="#rfc.section.7">Key Derivation</a></li>
<li>8.   <a href="#rfc.section.8">SessionID and Resumption Cookie Properties, Derivation, and Usage</a></li>
<li>9.   <a href="#rfc.section.9">Client Authentication</a></li>
<li>10.   <a href="#rfc.section.10">Security Considerations</a></li>
<li>11.   <a href="#rfc.references">References</a></li>
<ul><li>11.1.   <a href="#rfc.references.1">Normative References</a></li>
<li>11.2.   <a href="#rfc.references.2">Informative References</a></li>
</ul><li><a href="#rfc.authors">Authors' Addresses</a></li>


  </ul>

  <h1 id="rfc.section.1"><a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a></h1>
<p id="rfc.section.1.p.1">DISCLAIMER: This is a WIP draft of CCNxKE and has not yet seen significant security analysis.</p>
<p id="rfc.section.1.p.2">Ephemeral sessions a la TLS 1.3 <a href="#TLS13">[TLS13]</a> and QUIC <a href="#QUIC">[QUIC]</a> are needed for some CCN exchanges between consumers and producers. Currently, there does not exist a standard way to establish these sessions. Thus, the primary goal of the CCNxKE protocol is to provide privacy and data integrity between two CCN-enabled peers (e.g., a consumer and producer engaged in session-based communication). It is built on the CCNx 1.0 protocol and only relies upon standard Interest and Content Objects as a vehicle for communication.  The CCNxKE protocol is used to bootstrap session-based communication, wherein traffic is encapsulated and encrypted using symmetric-key cryptography for transmission between two endpoints (i.e., a consumer and producer). The CCNxKE protocol enables this form of communication by establishing shared state, i.e., shared, ephemeral, and forward-secure symmetric keys.  This protocol has the following three main properties:</p>
<p/>

<ul>
  <li>The peer&#8217;s identity can be authenticated using asymmetric, or public key, cryptography (e.g., RSA <a href="#RSA">[RSA]</a>, ECDSA <a href="#ECDSA">[ECDSA]</a>, etc.). This authentication can be made optional, but is generally required for at least one of the peers.</li>
  <li>The negotiation of a shared secret is secure from eavesdroppers and man-in-the-middle (MITM) attacks.</li>
  <li>The negotiation is reliable: no attacker can modify the negotiation communication without being detected by the parties to the communication.</li>
  <li>The state of a CCNx-KE session can be securely migrated between endpoints using a &#8220;move token.&#8221; This allows authentication and authorization to be separated from encryption for a session, enabling different systems to perform each of these steps.</li>
</ul>
<p id="rfc.section.1.p.4">Usage of CCNxKE is entirely independent of upper-layer application protocols.  Session-based communication via encapsulation and encryption enables secure, confidential, and authenticated communication between two peers. One advantage of this protocol is that it facilitates the creation and use of completely ephemeral CCN Interest and Content Objects.</p>
<p id="rfc.section.1.p.5">CCNxKE also introduces the use of reverse hash-chained nonces <a href="#HASHCHAIN">[HASHCHAIN]</a> in an Interest name to provide proof of a single continued message exchange. Prior TCP-based protocols, such as TLS <a href="#TLS13">[TLS13]</a>, use the TCP 3-way handshake for such proof.  Prior UDP-based protocols, such as QUIC <a href="#QUIC">[QUIC]</a>, use a session address token that must be presented by the client (consumer) to prove ownership of an address during a key exchange procedure.</p>
<p id="rfc.section.1.p.6">The main contribution of this work is adapting key exchange principles to the CCNx communications model. CCNxKE achieves its goals by applying existing key exchange techniques to the CCNx model of Named addresses and the Interest and Content Object pull model. CCNxKE only assumes that a consumer knows a first name that initiates the key exchange and understands the CCNxKE fields inside an Interest and Content Object. The first Interest does not need to be a CCNxKE packet &#8212; the producer can signal back to the consumer that it requires CCNxKE before progressing.</p>
<p id="rfc.section.1.p.7">Finally, note that this specification does not subsume other ICN-compliant key exchange protocols, nor does its existence imply that all encryption in an ICN must be based on sessions. It was designed specifically to solve the problem of session-based encryption in ICN.</p>
<h1 id="rfc.section.1.1"><a href="#rfc.section.1.1">1.1.</a> <a href="#conventions-and-terminology" id="conventions-and-terminology">Conventions and Terminology</a></h1>
<p id="rfc.section.1.1.p.1">The key words &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;REQUIRED&#8221;, &#8220;SHALL&#8221;, &#8220;SHALL NOT&#8221;, &#8220;SHOULD&#8221;, &#8220;SHOULD NOT&#8221;, &#8220;RECOMMENDED&#8221;, &#8220;NOT RECOMMENDED&#8221;, &#8220;MAY&#8221;, and &#8220;OPTIONAL&#8221; in this document are to be interpreted as described in RFC 2119 <a href="#RFC2119">[RFC2119]</a>.</p>
<p id="rfc.section.1.1.p.2">The following terms are used:</p>
<p id="rfc.section.1.1.p.3">Consumer: The CCN consumer initiating the CCNxKE key exchange via a first Interest.</p>
<p id="rfc.section.1.1.p.4">Producer: The CCN producer receiving or accepting the CCNxKE key exchange request request Interest.</p>
<p id="rfc.section.1.1.p.5">Sender: An endpoint that originates a message.</p>
<p id="rfc.section.1.1.p.6">Receiver: An endpoint that is receiving messages.</p>
<p id="rfc.section.1.1.p.7">Peer: An endpoint. When discussing a particular endpoint, &#8220;peer&#8221; refers to the endpoint that is remote to the primary subject of discussion.</p>
<p id="rfc.section.1.1.p.8">Connection: A network path of n &gt;= 1 hops between the consumer and producer.</p>
<p id="rfc.section.1.1.p.9">Endpoint: Either the consumer or producer of the connection.</p>
<p id="rfc.section.1.1.p.10">Handshake: A series of message exchanges between two peers that is used to perform a task (e.g., perform key exchange and derivation).</p>
<p id="rfc.section.1.1.p.11">Session: An association between a consumer and a producer resulting from a CCNxKE handshake.</p>
<p id="rfc.section.1.1.p.12">DH: A Diffie Hellman key exchange procedure <a href="#RFC2631">[RFC2631]</a> <a href="#DH">[DH]</a>.</p>
<p id="rfc.section.1.1.p.13">DH Share: One half of the shared-secret provided by one peer performing a DH key exchange.</p>
<p id="rfc.section.1.1.p.14">Forward-secure: The property that compromising any long-term secrets (e.g., cryptographic keys) does not compromise any session keys derived from those long-term secrets.</p>
<p id="rfc.section.1.1.p.15">CONFIG information: A data structure created by a producer which contains long-term cryptographic material and associated information needed by a client to initiate a key-exchange with the producer.</p>
<p id="rfc.section.1.1.p.16">HELLO exchange: An exchange between a consumer and producer wherein the consumer retrieves the CONFIG information from the producer.</p>
<p id="rfc.section.1.1.p.17">Payload: The payload section of a CCNxMessage as defined in <a href="#CCNxMessages">[CCNxMessages]</a>.</p>
<p id="rfc.section.1.1.p.18">KEPayload: A payload for information used in the CCNxKE protocol which is a generic key-value store. The KEPayload is <em>not</em> the CCNxMessage payload.</p>
<p id="rfc.section.1.1.p.19">CCNxName: A CCNxName as defined in <a href="#CCNxMessages">[CCNxMessages]</a>.</p>
<p id="rfc.section.1.1.p.20">Semi-static: Short-term.</p>
<p id="rfc.section.1.1.p.21">Short-term Secret (SS): A secret which is derived from the server&#8217;s semi-static DH share and the client&#8217;s fresh DH share.</p>
<p id="rfc.section.1.1.p.22">Forward-secure Secret (FSK): A secret which is derived from fresh (i.e., generated on demand at random) DH shares from both the consumer and producer for the given connection.</p>
<p id="rfc.section.1.1.p.23">HKDF: Hash-based key-derivation function <a href="#RFC5869">[RFC5869]</a>.</p>
<h1 id="rfc.section.2"><a href="#rfc.section.2">2.</a> <a href="#goals" id="goals">Goals</a></h1>
<p id="rfc.section.2.p.1">The goals of the CCNxKE protocol, in order of priority, are as follows:</p>
<p/>

<ol>
  <li>Cryptographic security: CCNxKE should be used to securely establish a session and all related shared secrets between two peers. Cryptographic properties of interest include: (a) forward-secure session key derivation and (b) (state and computational) denial-of-service prevention at the producer (see <a href="#RFC4987">[RFC4987]</a>). For property (a), different keys (and relevant algorithm parameters, such as IVs) are established for each communication direction, i.e., from consumer to producer and producer to consumer.</li>
  <li>Interoperability: Independent programmers should be able to develop applications utilizing CCNxKE that can successfully exchange cryptographic parameters without knowledge of one another&#8217;s code.</li>
  <li>Extensibility: CCNxKE seeks to provide a framework into which new public key and symmetric key methods and algorithms can be incorporated without breaking backwards compatability or requiring all clients to implement new functionality.  Moreover, the protocol should be able to support a variety of peer authentication protocols, e.g., EAP-TLS, EAP-PWD, or a simple challenge-response protocol.</li>
  <li>Relative efficiency: CCNxKE tries to create sessions with minimal computation, bandwidth, and message complexity. In particular, it seeks to create sessions with as few end-to-end round trips as possible, and also provide support for accelerated session establishment and resumption when appropriate. At most 2 round-trip-times (RTTs) should be used to establish a session key, with the possibility of 1 or 0 RTT accelerated starts and resumption.</li>
</ol>
<h1 id="rfc.section.3"><a href="#rfc.section.3">3.</a> <a href="#scope" id="scope">Scope</a></h1>
<p id="rfc.section.3.p.1">This document and the CCNxKE protocol are highly influenced by the TLS 1.3 <a href="#TLS13">[TLS13]</a> and QUIC <a href="#QUIC">[QUIC]</a> protocols. The reader, however, does not need a detailed understanding of those protocols to understand this document. Moreover, where appropriate, references to related protocols are made for brevity and technical clarity. This document is intended primarily for readers who will be implementing the protocol and for those doing cryptographic analysis of it. The specification has been written with this in mind, and it is intended to reflect the needs of those two groups.</p>
<p id="rfc.section.3.p.2">Note that this document is not intended to supply any details of service definition or of interface definition, although it does cover select areas of policy as they are required for the maintenance of solid security.</p>
<h1 id="rfc.section.4"><a href="#rfc.section.4">4.</a> <a href="#presentation-language" id="presentation-language">Presentation Language</a></h1>
<p id="rfc.section.4.p.1">This document uses a presentation language of remote calls (i.e. packet messages) similar to the format used by TLS <a href="#TLS13">[TLS13]</a>.</p>
<h1 id="rfc.section.5"><a href="#rfc.section.5">5.</a> <a href="#ccnxke-overview" id="ccnxke-overview">CCNxKE Overview</a></h1>
<h1 id="rfc.section.5.1"><a href="#rfc.section.5.1">5.1.</a> <a href="#connection-establishment-latency" id="connection-establishment-latency">Connection Establishment Latency</a></h1>
<p id="rfc.section.5.1.p.1">CCNxKE operates in three rounds, where each round requires a single RTT to complete. The full execution of the protocol therefore requires 2 RTTs before a session is fully established. The full version is used when consumers have no a priori information about the producer. An accelerated two round version is used when the consumer has valid configuration information about the producer; this variant requires 1 RTT before a session is established.  Finally, the quickest execution of the protocol requires only a single round to resume a previous session (similar to the goal of <a href="#RFC5077">[RFC5077]</a>). Indeed, if 0 RTT latency is desired then the consumer must also include application data in this initial round.</p>
<h1 id="rfc.section.5.2"><a href="#rfc.section.5.2">5.2.</a> <a href="#connection-migration-and-resumption" id="connection-migration-and-resumption">Connection Migration and Resumption</a></h1>
<p id="rfc.section.5.2.p.1">CCN end hosts lack the notion of addresses. Thus, the producer endpoint for a given execution of the CCNxKE protocol is one which can authoritatively serve as the owner of a particular namespace. For example, a consumer may wish to establish a session with a producer who owns the /company/foo namespace.  The specific end host which partakes in the protocol instance is not specified, by virtue of the fact that all CCNxKE messages are based on well-defined names.  This enables the producer end-host which partakes in the protocol to change based on the name of the CCNxKE messages. Consequently, to maintain correctness, it is important that a single execution of the protocol operates within the same trusted context; this does not mean that the same producer end-host is required to participate in all three steps of the protocol.  Rather, it means that the end-host responding to a CCNxKE message must be trusted by the consumer to complete the exchange. CCNxKE is designed to enable this sort of producer migration.</p>
<p id="rfc.section.5.2.p.2">For example, a consumer may use an initial name like &#8216;/parc/index.html&#8217; that works like an IP any cast address and could got to one of several systems.  CCNxKE allows the responding endpoint to include a localized name to ensure that subsequent messages from the consumer come back to the same producer.  CCNxKE also allows the key exchange peer to securely hand-off the session to a content producer peer via another name and session token once the client is authenticated and keying material is exchanged.</p>
<h1 id="rfc.section.5.3"><a href="#rfc.section.5.3">5.3.</a> <a href="#re-transmissions-timeouts-and-replay-prevention" id="re-transmissions-timeouts-and-replay-prevention">Re-Transmissions, Timeouts, and Replay Prevention</a></h1>
<p id="rfc.section.5.3.p.1">CCNxKE timeouts and retransmissions are handled using the approach in <a href="#RFC6347">[RFC6347]</a>.  One primary difference is that timer values may need to be adjusted (elongated) due to prefix shifts and the need for a producer to transfer security information between different machines.</p>
<p id="rfc.section.5.3.p.2">Replay attack prevention is also an optional feature, and if used, MAY be done using one of the following two approaches at the receiver (producer):</p>
<p/>

<ul>
  <li>IPSec AH <a href="#RFC4302">[RFC4302]</a> and ESP <a href="#RFC4303">[RFC4303]</a> style replay detection based on sliding windows and monotonically increasing sequence numbers for windows. Note that the sliding window inherently limits the performance of the protocol to the window size, since only a finite number of messages may be received within a given window (based on the window size).</li>
  <li>The optimized anti-replay algorithm of <a href="#RFC6479">[RFC6479]</a>.</li>
</ul>
<h1 id="rfc.section.6"><a href="#rfc.section.6">6.</a> <a href="#the-ccnxke-protocol" id="the-ccnxke-protocol">The CCNxKE Protocol</a></h1>
<p id="rfc.section.6.p.1">This section describes the CCNxKE protocol in detail at the message level. The specific encoding of those messages is given later. CCNxKE could be adapted to different wire format encodings, such as those used by the NDN protocol.</p>
<p id="rfc.section.6.p.2">The following assumptions are made about peers participating in the CCNxKE protocol:</p>
<p/>

<ul>
  <li>Consumers know the namespace prefix of the producer for which they wish to execute the CCNxKE protocol.</li>
  <li>The CCNxInterest carries a distinguished field that contains CCNxKE fields.</li>
  <li>The CCNxContentObject carries a distinguished field &#8212; separate from the Payload &#8212; that contains the CCNxKE field. This is necessary for 0 RTT packets that carry both keying material and application payload.</li>
  <li>CCNxKE does not require any special behavior of intermediate systems to forward packets.</li>
  <li>CCNxKE packets generally should not be cached for significant periods of time, as use normal protocol methods to limit caching. Part of this is achieved through the use of consumer-specific nonces in names.</li>
</ul>
<h1 id="rfc.section.6.1"><a href="#rfc.section.6.1">6.1.</a> <a href="#round-overview" id="round-overview">Round Overview</a></h1>
<p id="rfc.section.6.1.p.1">CCNxKE is composed of three rounds. The purpose of each round is described below.</p>
<p/>

<ul>
  <li>Round 1: Perform a bare HELLO exchange to obtain the public parameters and CONFIG information (detailed later) provided by the producer. The CONFIG information is relatively long-term cryptographic material generated by the producer and does not require significant computation to produce. After this round the consumer is in possession of the producer CONFIG information that is used to begin the real key exchange.</li>
  <li>Round 2: Perform the initial FULL-HELLO exchange to establish a forward-secure key used for future communication, i.e., Interest and Content Object exchanges in the context of the newly established session.</li>
  <li>Round 3: Send the first bit of application data and (optionally) transfer resumption cookie(s) from the producer to the consumer.</li>
</ul>
<p id="rfc.section.6.1.p.3">Conceptually, there are two secrets that are established during a single execution of CCNxKE:</p>
<p/>

<ul>
  <li>Short-term Secret (SS): A secret which is derived from the server&#8217;s semi-static DH share and the client&#8217;s fresh DH share. Keying material derived from SS is not forward secure.</li>
  <li>Forward-secure Secret (FSK): A secret which is derived from fresh DH shares from both the consumer and producer for the given connection. Keying material derived from FSK is intended to be forward secure.</li>
</ul>
<p id="rfc.section.6.1.p.5">All secrets are derived with the appropriate amount of randomness <a href="#RFC4086">[RFC4086]</a>.  An overview of the messages sent in each of the three rounds to establish and use these secrets is shown in Figure <a href="#ccnxke-high">Figure 1</a> below.  This diagram omits the optional session migration tokens and the quick restart cookie.</p>
<div id="rfc.figure.1"/>
<div id="ccnxke-high"/>
<pre>
    Consumer                                           Producer

    Payload:
    HELLO
                        I[/prefix/nonce1]
                            --------&gt;
                                                        Payload:
                                                          Config
                                                          nonce2*
                                                            salt*
                        CO[/prefix/nonce1]
                            &lt;---------
    Payload:
    ClientShare1
    {AlgorithmOptions}
    {NonceTarget}
    {ClientShare2}
                        I[/prefix/nonce2]
                            --------&gt;
                                                        Payload:
                                                       SessionID
                                                           {ACK}
                                                  {ServerShare2}
                                                            [RC]
                        CO[/prefix/nonce2]
                            &lt;---------
    Payload:
    [ConsumerData]

                        I[/prefix/SessionID/[...]]
                            --------&gt;
                                                        Payload:
                                                  [ProducerData]
                        CO[/prefix/SessionID/[...]]
                            &lt;--------

    (Repeat with data)      &lt;--------&gt;       (Repeat with data)

            *  Indicates optional or situation-dependent
               messages that are not always sent.

            {} Indicates messages protected using keys
               derived from the short-term secret (SS)

            [] Indicates messages protected using keys
               derived from the forward-secure secret (FSK).
</pre>
<p class="figure">Figure 1: High-level message flow for full CCNxKE protocol</p>
<p id="rfc.section.6.1.p.6">In the following sections, we will describe the format of each round in this protocol in more detail.</p>
<p id="rfc.section.6.1.p.7">We do not specify the encoding of messages sent in Interest and Content Object payloads. Any viable encoding will suffice, so long as both parties agree upon the type. For example, the payload could be structured and encoded as a JSON object whose, e.g.,</p>
<p id="rfc.section.6.1.p.8">{ &#8220;Config&#8221;: CONFIG, &#8220;nonce2&#8221;: nonce2<em>, &#8220;salt&#8221;: salt</em> }</p>
<p id="rfc.section.6.1.p.9">For now, we assume some valid encoding mechanism is used to give structure to message payloads.</p>
<h1 id="rfc.section.6.2"><a href="#rfc.section.6.2">6.2.</a> <a href="#round-1" id="round-1">Round 1</a></h1>
<p id="rfc.section.6.2.p.1">Recall that the purpose of Round 1 is to acquire the CONFIG information used in Round 2 of the protocol. To that end, the format of the Round 1 message is trivial.  First, the client issues an Interest with the following name</p>
<pre>
    /prefix/nonce1
</pre>
<p id="rfc.section.6.2.p.2">and a HELLO KEPayload with the following information:</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
  <thead>
    <tr>
      <th class="left">HELLO Field</th>
      <th class="left">Description</th>
      <th class="left">Optional?</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="left">CCS</td>
      <td class="left">Compressed certificate set that the consumer possesses. This is used for generating</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">authenticators by the server. See <a href="#QUIC">[QUIC]</a> for more details.</td>
      <td class="left">No</td>
      <td class="left"/>
    </tr>
    <tr>
      <td class="left">CCRT</td>
      <td class="left">Cached certificates in the consumer&#8217;s possession</td>
      <td class="left">No</td>
    </tr>
    <tr>
      <td class="left">VER</td>
      <td class="left">Supported CCNxKE protocol version(s)</td>
      <td class="left">No</td>
    </tr>
    <tr>
      <td class="left">PROOF</td>
      <td class="left">Proof of demand (i.e., a sorted list of types of proof the consumer will expect)</td>
      <td class="left">No</td>
    </tr>
    <tr>
      <td class="left">NONCE1</td>
      <td class="left">A 32-byte hash digest computed over a random input NONCE-TOKEN (used later) using SHA-256</td>
      <td class="left">No</td>
    </tr>
  </tbody>
</table>
<p id="rfc.section.6.2.p.3">Upon receipt of this interest, the producer responds with a HELLO-REJECT Content Object whose KEPayload has the following fields:</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
  <thead>
    <tr>
      <th class="left">HELLO-REJECT Field</th>
      <th class="left">Description</th>
      <th class="left">Optional?</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="left">{REJ}</td>
      <td class="left">Rejection flag</td>
      <td class="left">No</td>
    </tr>
    <tr>
      <td class="left">{REASON}</td>
      <td class="left">Reason for rejection</td>
      <td class="left">No</td>
    </tr>
    <tr>
      <td class="left">CONFIG</td>
      <td class="left">The server CONFIG information</td>
      <td class="left">Yes</td>
    </tr>
    <tr>
      <td class="left">NONCE2</td>
      <td class="left">An optional 32-byte nonce to use for the following message in the CCNxKE instance</td>
      <td class="left">Yes</td>
    </tr>
    <tr>
      <td class="left">PSALT1</td>
      <td class="left">An optional 32-byte salt to use when deriving SS</td>
      <td class="left">Yes</td>
    </tr>
    <tr>
      <td class="left">PREFIX2</td>
      <td class="left">An optional CCNxName prefix to use when continuing the session establishment protocol in Round 2</td>
      <td class="left">Yes</td>
    </tr>
  </tbody>
</table>
<p id="rfc.section.6.2.p.4">Recall that the CONFIG information is a semi-static catalog of information that consumers can use to complete future key exchanges with the producer. The fields of the CONFIG information are shown below.</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
  <thead>
    <tr>
      <th class="left">CONFIG Information Field</th>
      <th class="left">Description</th>
      <th class="left">Optional?</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="left">SCID</td>
      <td class="left">Server configuration ID</td>
      <td class="left">Yes</td>
    </tr>
    <tr>
      <td class="left">KEXS</td>
      <td class="left">Supported elliptic-curve key-exchange algorithms</td>
      <td class="left">No</td>
    </tr>
    <tr>
      <td class="left">AEAD</td>
      <td class="left">Supported AEAD algorithms</td>
      <td class="left">No</td>
    </tr>
    <tr>
      <td class="left">PUBS</td>
      <td class="left">List of public values (for key exchange algorithm) encoded appropriately for the given group</td>
      <td class="left">No</td>
    </tr>
    <tr>
      <td class="left">EXPRY</td>
      <td class="left">Expiration timestamp (i.e., longevity of the CONFIG structure)</td>
      <td class="left">No</td>
    </tr>
    <tr>
      <td class="left">VER</td>
      <td class="left">Version of the CONFIG structure</td>
      <td class="left">Yes</td>
    </tr>
  </tbody>
</table>
<p id="rfc.section.6.2.p.5">The KEXS is a data structure that enumerates the elliptic curve key-exchange algorithms that are supported by the producer (see <a href="#QUIC">[QUIC]</a> for more details). Currently, only the following curves are supported:</p>
<p/>

<ul>
  <li>Curve25519</li>
  <li>P-256</li>
</ul>
<p id="rfc.section.6.2.p.7">Selection criteria for these curves is given at http://safecurves.cr.yp.to/.</p>
<p id="rfc.section.6.2.p.8">The AEAD structure enumerates the supported AEAD algorithms used for symmetric-key authenticated encryption after the session has been established. Currently, the only supported algorithms are:</p>
<p/>

<ul>
  <li>AES-GCM-(128,192,256) <a href="#GCM">[GCM]</a>: a 12-byte tag is used, where the first four bytes are taken from the FSK key-derivation step and the last eight are taken from the initial consumer nonce.</li>
  <li>Salsa20 <a href="#SALSA20">[SALSA20]</a> (stream cipher) with Poly1305 (MAC).</li>
</ul>
<p id="rfc.section.6.2.p.10">The key sizes and related parameters are provided with the AEAD tag in the CONFIG structure.</p>
<p id="rfc.section.6.2.p.11">((TODO: the exact structure of the AEAD needs to be spelled out here for completeness.))</p>
<p id="rfc.section.6.2.p.12">The PUBS structure contains the public values for the initial key exchange. Both Curve25519 and P-256 provide their own set of accepted parameters. Thus, the only values provided here are the random curve elements used in the DH operation.</p>
<h1 id="rfc.section.6.3"><a href="#rfc.section.6.3">6.3.</a> <a href="#round-2" id="round-2">Round 2</a></h1>
<p id="rfc.section.6.3.p.1">Recall that the purpose of Round 2 is to perform the initial FULL-HELLO exchange to establish a forward-secure key used for future communication. It is assumed that the consumer already has the CONFIG information that is provided from the producer in Round 1. Moreover, assume that nonce2 is a ephemeral nonce provided by the producer in Round 1. Then, the consumer issues an Interest with the following name:</p>
<pre>
    /prefix/nonce2
</pre>
<p id="rfc.section.6.3.p.2">and a KEPayload with the following information:</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
  <thead>
    <tr>
      <th class="left">FULL-HELLO Field</th>
      <th class="left">Description</th>
      <th class="left">Optional?</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="left">CLIENT-SHARE1</td>
      <td class="left">Client public share for the initial DH exchange</td>
      <td class="left">No</td>
    </tr>
    <tr>
      <td class="left">CSALT1</td>
      <td class="left">Client salt for initial DH exchange and SS generation</td>
      <td class="left">Yes</td>
    </tr>
    <tr>
      <td class="left">PSALT1</td>
      <td class="left">Echoed producer salt (not optional if the server provided one)</td>
      <td class="left">Yes</td>
    </tr>
    <tr>
      <td class="left">{PROOF}</td>
      <td class="left">Proof of demand (i.e., a sorted list of types of proof the consumer will expect)</td>
      <td class="left">No</td>
    </tr>
    <tr>
      <td class="left">{CCS}</td>
      <td class="left">Compressed certificate set that the consumer possesses</td>
      <td class="left">No</td>
    </tr>
    <tr>
      <td class="left">{CHALLENGE}</td>
      <td class="left">A random 32-byte challenge that is to be signed by the producer</td>
      <td class="left">No</td>
    </tr>
    <tr>
      <td class="left">{CHOICE}</td>
      <td class="left">Algorithm (KEXS and AEAD) options choice (a list of tags echoed from the server CONFIG)</td>
      <td class="left">No</td>
    </tr>
    <tr>
      <td class="left">{NONCE-TOKEN}</td>
      <td class="left">The preimage such that SHA-256(NONCE-TOKEN) = NONCE1</td>
      <td class="left">No</td>
    </tr>
    <tr>
      <td class="left">{CLIENT-SHARE2}</td>
      <td class="left">Second share for generating the ephemeral key</td>
      <td class="left">No</td>
    </tr>
    <tr>
      <td class="left">{CSALT2}</td>
      <td class="left">Client salt for generating the FSK key</td>
      <td class="left">Yes</td>
    </tr>
  </tbody>
</table>
<p id="rfc.section.6.3.p.3">Upon receipt of this interest, the producer performs the DH computation to compute SS, decrypts all protected fields in the consumer&#8217;s KEPayload, and validates the algorithm choice selection (CHOICE). If any of these steps fail, the producer replies with with a HELLO-REJECT Content Object whose KEPayload contains a REJ flag and the reason of the error.  If the above steps complete without failure or error, then the producer responds with a Content Object whose KEPayload has the following fields:</p>
<table cellpadding="3" cellspacing="0" class="tt full center">
  <thead>
    <tr>
      <th class="left">HELLO-ACCEPT Field</th>
      <th class="left">Description</th>
      <th class="left">Optional?</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td class="left">SessionID</td>
      <td class="left">Cleartext session identifier</td>
      <td class="left">No</td>
    </tr>
    <tr>
      <td class="left">[RC]</td>
      <td class="left">Resumption cookie encrypted under a FSK-derived key</td>
      <td class="left">Yes</td>
    </tr>
    <tr>
      <td class="left">{ACK}</td>
      <td class="left">Positive ACK flag indicating success</td>
      <td class="left">No</td>
    </tr>
    <tr>
      <td class="left">{RESPONSE}</td>
      <td class="left">The signed output of the CHALLENGE according to the PROOF preferences and CCS certificates in possession of the consumer</td>
      <td class="left">No</td>
    </tr>
    <tr>
      <td class="left">{PSALT2}</td>
      <td class="left">32-byte producer salt for the FSK key exchange</td>
      <td class="left">Yes</td>
    </tr>
    <tr>
      <td class="left">{SERVER-SHARE2}</td>
      <td class="left">Server&#8217;s public key share to use when generating MSK</td>
      <td class="left">No</td>
    </tr>
    <tr>
      <td class="left">{(Prefix3,MoveToken)}</td>
      <td class="left">Third CCNxName prefix and token to use when moving to session establishment</td>
      <td class="left">Yes</td>
    </tr>
  </tbody>
</table>
<p id="rfc.section.6.3.p.4">((TODO: we need to spell out what type of flag ACK is (a bit? byte?)))</p>
<h1 id="rfc.section.6.4"><a href="#rfc.section.6.4">6.4.</a> <a href="#round-3" id="round-3">Round 3</a></h1>
<p id="rfc.section.6.4.p.1">In Round 3, the consumer sends interests whose name and optional Payload are encrypted using one of the forward-secure keys derived after Round 2. In normal operation, the producer will respond with Content Objects whose Payloads are encrypted using a different forward-secure key. That is, interests and Content Objects are encrypted and authenticated using two separate keys. The producer may also optionally provide a new resumption cookie (RC) with a Content Object response. This is used to keep the consumer&#8217;s resumption cookie fresh and to also support 0 RTT resumption. In this case, the producer&#8217;s Content Object response has the following fields:</p>
<p/>

<ul>
  <li>Payload: the actual Content Object payload data encrypted with the producer&#8217;s forward-secure key.</li>
  <li>RC&#8217;: A new resumption cookie to be used for resuming this session in the future.</li>
</ul>
<p id="rfc.section.6.4.p.3">The producer is free to choose the frequency at which new resumption cookies are issued to the consumer.</p>
<h1 id="rfc.section.7"><a href="#rfc.section.7">7.</a> <a href="#key-derivation" id="key-derivation">Key Derivation</a></h1>
<p id="rfc.section.7.p.1">The goal of the CCNxKE protocol is to establish the following key material:</p>
<pre>
consumer write key (FSK-C)
producer write key (FSK-P)
consumer write IV  (IV-C)
producer write IV  (IV-P)
</pre>
<p id="rfc.section.7.p.2">To get this material, first the SS must be derived. We use the HKDF <a href="#RFC5869">[RFC5869]</a> function for all key derivation and expansion. Also, the DH operation produces a 32-byte value that used for the HKDF-Expand function.</p>
<div id="rfc.figure.2"/>
<div id="ss-derive"/>
<pre>
  SS = HKDF(Salt, IKM)
Salt = CSALT1 || PSALT1 || &#8220;ss generation&#8221;
 IKM = DH(CLIENT-SHARE1, SERVER-SHARE1)
</pre>
<p class="figure">Figure 2: SS Derivation. SERVER-SHARE1 is the share corresponding to the consumer's CHOICE selection in Round 2.</p>
<div id="rfc.figure.3"/>
<div id="fsk-derive"/>
<pre>
 FSK = HKDF(Salt, IKM)
Salt = CSALT2 || PSALT2 || &#8220;fsk generation&#8221;
 IKM = DH(CLIENT-SHARE2, SERVER-SHARE2)
</pre>
<p class="figure">Figure 3: SS Derivation. SERVER-SHARE1 is the share corresponding to the consumer's CHOICE selection in Round 2.</p>
<p id="rfc.section.7.p.3">The keying material FSK-C/P and IV-C/P are then expanded from the FSK forward-secure secret in the following order using the HKDF-Expand function.</p>
<pre>
FSK-C
FSK-P
IV-C
IV-P
</pre>
<h1 id="rfc.section.8"><a href="#rfc.section.8">8.</a> <a href="#sessionid-and-resumption-cookie-properties-derivation-and-usage" id="sessionid-and-resumption-cookie-properties-derivation-and-usage">SessionID and Resumption Cookie Properties, Derivation, and Usage</a></h1>
<p id="rfc.section.8.p.1">The purpose of the session identifier SessionID is to uniquely identify a single session for the producer and consumer. A Producer MAY use a random bit string or MAY use the method described in this section or MAY use another proprietary method to distinguish clients.</p>
<p id="rfc.section.8.p.2">We provide a more secure creation of the SessionID since it is used with the RC derivation (defined later). Specifically, the SessionID is derived as the encryption of the hash digest of a server secret, FSK, and an optional prefix (e.g., Prefix3). Encryption is done by the using a long-term secret key owned by the server used for only this purpose, i.e., it is not used for consumer traffic encryption. Mechanically, this derivation is:</p>
<pre>
SessionID = Enc(k1, H(secret || FSK || (Prefix3 | ""))),
</pre>
<p id="rfc.section.8.p.3">where k1 is the long-term producer key, and &#8220;secret&#8221; is the producer&#8217;s secret.</p>
<p id="rfc.section.8.p.4">For the resumption cookie, we require that it must be able to be used to recover the SS and FSK for a given session. Without SS and FSK, correct session communication is not possible. We derive it as the encryption of the hash digest of the server secret, SS, FSK, and the optional (Prefix3, MoveToken) tuple (if created for the session). The producer must use a long-term secret key for this encryption. Mechanically, this derivation is:</p>
<pre>
RC = Enc(k2, SS || FSK || ((Prefix3 || MoveToken) | "")),
</pre>
<p id="rfc.section.8.p.5">where k2 is again a long-term producer key. Note that it may be the case that k1 = k2 (see above), though this is not required.</p>
<p id="rfc.section.8.p.6">With this SessionID and RC, the consumer then resumes a session by providing both the SessionID and RC to the producer. This is done to prove to the producer that the consumer who knows the SessionID is also in possession of the correct RC.  The producer verifies this by computing</p>
<pre>
(SS || FSK || ((Prefix3 || MoveToken)| "")) = Dec(k2, RC)
</pre>
<p id="rfc.section.8.p.7">and checking the following equality</p>
<pre>
SessionID = Enc(k1, H( secret || FSK || ( Prefix3 | "")))
</pre>
<p id="rfc.section.8.p.8">If equality holds, the producer uses the SS and FSK recovered from RC to re-initialize the previous session with the consumer.</p>
<h1 id="rfc.section.9"><a href="#rfc.section.9">9.</a> <a href="#client-authentication" id="client-authentication">Client Authentication</a></h1>
<p id="rfc.section.9.p.1">Currently, only the producer is authenticated in the CCNxKE protocol using a standard challenge-response protocol. This could be extended to enable mutual authentication for the client by adding a challenge-response exchange from the producer to the consumer in Rounds 2 and 3. That is, the producer could return a CHALLENGE in Round 2, to which the consumer is expected to sign and return as a RESPONSE in Round 3 before the producer accepts any application data.</p>
<p id="rfc.section.9.p.2">Additional authentication mechanisms based on EAP may also be used, including:</p>
<p/>

<ul>
  <li>EAP-TLS: EAP based on a TLS-like exchange.</li>
  <li>EAP-PWD: EAP based on a password.</li>
  <li>EAP-PSK: EAP based on a pre-shared key.</li>
</ul>
<p id="rfc.section.9.p.4">(( TODO: should we add examples for each of the above variants? ))</p>
<h1 id="rfc.section.10"><a href="#rfc.section.10">10.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a></h1>
<p id="rfc.section.10.p.1">For CCNxKE to be able to provide a secure connection, both the consumer and producer systems, keys, and applications must be secure. In addition, the implementation must be free of security errors.</p>
<p id="rfc.section.10.p.2">The system is only as strong as the weakest key exchange and authentication algorithm supported, and only trustworthy cryptographic functions should be used. Short public keys and anonymous servers should be used with great caution. Implementations and users must be careful when deciding which certificates and certificate authorities are acceptable; a dishonest certificate authority can do tremendous damage.</p>
<h1 id="rfc.references"><a href="#rfc.references">11.</a> References</h1>
<h1 id="rfc.references.1"><a href="#rfc.references.1">11.1.</a> Normative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="CCNxMessages">[CCNxMessages]</b>
      </td>
      <td class="top"><a title="PARC, Inc.">Mosko, M.</a> and <a title="PARC, Inc.">I. Solis</a>, "<a href="https://tools.ietf.org/html/draft-irtf-icnrg-ccnxmessages-00">CCNx Messages in TLV Format</a>", June 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="DH">[DH]</b>
      </td>
      <td class="top"><a>Diffie, W.</a> and <a>M. Hellman</a>, "<a>New Directions in Cryptography</a>", IEEE Transactions on Information Theory, V.IT-22 n.6 , June 1977.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="ECDSA">[ECDSA]</b>
      </td>
      <td class="top"><a>American National Standards Institute</a>, "<a>Public Key Cryptography for the Financial Services Industry: The Elliptic Curve Digital Signature Algorithm (ECDSA)</a>", ANSI ANS X9.62-2005, November 2005.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="GCM">[GCM]</b>
      </td>
      <td class="top"><a>Dworkin, M.</a>, "<a>Recommendation for Block Cipher Modes of Operation: Galois/Counter Mode (GCM) and GMAC</a>", NIST Special Publication 800-38D, November 2007.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="QUIC">[QUIC]</b>
      </td>
      <td class="top"><a title="Google">Iyengar, J.</a> and <a title="Google">I. Swett</a>, "<a>QUIC: A UDP-Based Secure and Reliable Transport for HTTP/2</a>", December 2015.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2119">[RFC2119]</b>
      </td>
      <td class="top"><a>Bradner, S.</a>, "<a href="http://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC2631">[RFC2631]</b>
      </td>
      <td class="top"><a>Rescorla, E.</a>, "<a href="http://tools.ietf.org/html/rfc2631">Diffie-Hellman Key Agreement Method</a>", RFC 2631, DOI 10.17487/RFC2631, June 1999.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4086">[RFC4086]</b>
      </td>
      <td class="top"><a>Eastlake 3rd, D.</a>, <a>Schiller, J.</a> and <a>S. Crocker</a>, "<a href="http://tools.ietf.org/html/rfc4086">Randomness Requirements for Security</a>", BCP 106, RFC 4086, DOI 10.17487/RFC4086, June 2005.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4302">[RFC4302]</b>
      </td>
      <td class="top"><a>Kent, S.</a>, "<a href="http://tools.ietf.org/html/rfc4302">IP Authentication Header</a>", RFC 4302, DOI 10.17487/RFC4302, December 2005.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4303">[RFC4303]</b>
      </td>
      <td class="top"><a>Kent, S.</a>, "<a href="http://tools.ietf.org/html/rfc4303">IP Encapsulating Security Payload (ESP)</a>", RFC 4303, DOI 10.17487/RFC4303, December 2005.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC4987">[RFC4987]</b>
      </td>
      <td class="top"><a>Eddy, W.</a>, "<a href="http://tools.ietf.org/html/rfc4987">TCP SYN Flooding Attacks and Common Mitigations</a>", RFC 4987, DOI 10.17487/RFC4987, August 2007.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5869">[RFC5869]</b>
      </td>
      <td class="top"><a>Krawczyk, H.</a> and <a>P. Eronen</a>, "<a href="http://tools.ietf.org/html/rfc5869">HMAC-based Extract-and-Expand Key Derivation Function (HKDF)</a>", RFC 5869, DOI 10.17487/RFC5869, May 2010.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6347">[RFC6347]</b>
      </td>
      <td class="top"><a>Rescorla, E.</a> and <a>N. Modadugu</a>, "<a href="http://tools.ietf.org/html/rfc6347">Datagram Transport Layer Security Version 1.2</a>", RFC 6347, DOI 10.17487/RFC6347, January 2012.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC6479">[RFC6479]</b>
      </td>
      <td class="top"><a>Zhang, X.</a> and <a>T. Tsou</a>, "<a href="http://tools.ietf.org/html/rfc6479">IPsec Anti-Replay Algorithm without Bit Shifting</a>", RFC 6479, DOI 10.17487/RFC6479, January 2012.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RSA">[RSA]</b>
      </td>
      <td class="top"><a>Rivest, R.</a>, <a>Shamir, A.</a> and <a>L. Adleman</a>, "<a>A Method for Obtaining Digital Signatures and Public-Key Cryptosystems</a>", Communications of the ACM v. 21, n. 2, pp. 120-126., February 1978.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="SALSA20">[SALSA20]</b>
      </td>
      <td class="top"><a>Bernstein, D.</a>, "<a>Salsa20 specification</a>", www.http://cr.yp.to/snuffle/spec.pdf , April 2005.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="TLS13">[TLS13]</b>
      </td>
      <td class="top"><a title="RTFM, Inc.">Rescorla, E.</a>, "<a>The Transport Layer Security (TLS) Protocol Version 1.3</a>", August 2015.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.references.2"><a href="#rfc.references.2">11.2.</a> Informative References</h1>
<table>
  <tbody>
    <tr>
      <td class="reference">
        <b id="HASHCHAIN">[HASHCHAIN]</b>
      </td>
      <td class="top"><a>L. Lamport</a>, "<a>Password Authentication with Insecure Communication</a>", ANSI Communications of the ACM 24.11, pp 770-772, November 1981.</td>
    </tr>
    <tr>
      <td class="reference">
        <b id="RFC5077">[RFC5077]</b>
      </td>
      <td class="top"><a>Salowey, J.</a>, <a>Zhou, H.</a>, <a>Eronen, P.</a> and <a>H. Tschofenig</a>, "<a href="http://tools.ietf.org/html/rfc5077">Transport Layer Security (TLS) Session Resumption without Server-Side State</a>", RFC 5077, DOI 10.17487/RFC5077, January 2008.</td>
    </tr>
  </tbody>
</table>
<h1 id="rfc.authors">
  <a href="#rfc.authors">Authors' Addresses</a>
</h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">M. Mosko</span> 
	  <span class="n hidden">
		<span class="family-name">Mosko</span>
	  </span>
	</span>
	<span class="org vcardline">PARC</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:marc.mosko@parc.com">marc.mosko@parc.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Ersin Uzun</span> 
	  <span class="n hidden">
		<span class="family-name">Uzun</span>
	  </span>
	</span>
	<span class="org vcardline">PARC</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:ersin.uzun@parc.com">ersin.uzun@parc.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Christopher A. Wood</span> 
	  <span class="n hidden">
		<span class="family-name">Wood</span>
	  </span>
	</span>
	<span class="org vcardline">PARC</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:christopher.wood@parc.com">christopher.wood@parc.com</a></span>

  </address>
</div>

</body>
</html>
